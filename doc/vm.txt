1. Virtual machine design goals

- To establish a memory-safe concurrent environment in a single address space.
- To support transparent remote procedure calls.
- To be as simple as possible, but not simpler.

2. Variables

When thread executes a module procedure it reads and writes variables. Each
variable is a sequential block of memory organized as an array of equal sized
elements.

Variable element can hold three sections (each one may present or may not):
- bytes: array of bytes available for arithmetic and logical manipulations.
- vrefs: array of references to heap-allocated variables.
- prefs: array of references to procedures.

Concrete structure of a variable element is described by a variable type. A
variable in whole is described by flags (it's special properties), variable
type and positive element count. These three characteristics together are
called variable specificator.

Variable type consists of element byte array size, array of variable
specificators, which correspond to element's variable references and procedure
ids, which correspond to element's procedure references.

Variable specificator supports the following flags:
- VFLAG_NON_FIXED_REF: referred variable has non-fixed element count.
- VFLAG_TOP_LEVEL_REG: register has top-level variable. This flag can be used
  only in register definitions.
- VFLAG_THREAD_LOCAL_REG: register top-level variable is thread-local. Must be
  used in combination with VFLAG_TOP_LEVEL_REG. This flag can be used only in
  register definitions.

Heap-allocated variables are managed by reference counting collector. Such
variables hold reference counters. Each new reference to heap-allocated
variable increments the counter ("retains" it). Each reference loss decrements
the counter ("releases" it). When the counter becomes equal to zero the
variable is being destroyed, and all variables pointed by it's references are
released.

Heap-allocated variables with non-fixed element count keep their actual element
counts which are set at creation time. In such case the actual element count
supersedes an element count of corresponding variable specificator.

3. Registers

Variables are not accessed directly, but via registers. Register can be
statically assigned to top-level variable, or dynamically assigned using stack
frame manipulation instructions. Register is described by variable specificator
which corresponds to variables the register can be assigned to.

Predefined registers:
- ED (=0): top-level thread-local 8-byte variable holding an exception
  descriptor.

4. Procedure types

Procedure type describes an interface of procedure. It consists of flags (it's
special properties) and IO register. When procedure is called, it reads
arguments from IO register of it's type. Before returning it places result into
same the IO register.

Procedure type supports the following flags:
- PTFLAG_READER: procedure reads mutable data, shared between threads.
- PTFLAG_WRITER: procedure modifies mutable data, shared between threads.

5. Procedures

Procedure is described by flags (it's special properties), it's type and code.

Procedure supports the following flags:
- PFLAG_EXTERNAL: procedure is accessible from outside of the module.

6. Instructions

Argument prefixes designators:
- '@': any register.
- '%': register assigned to variable with at least 1 element; otherwise
  exception with code VMECODE_NULL_REFERENCE will be thrown.
- '#n': : same as '%', but the variable must have at least n bytes in element.
- '#': same as '#8'.
- '<': register assigned to variable reference (can be null).
- '!': register assigned to stack allocated variable.
- '$': immediate integer value.

The instructions bellow are listed in alphabetical order. 

- ADD #op1, #op2, #res
Adds 'op1' to 'op2' and puts the result to 'res'.

- CALL $proc
Calls procedure 'proc' of a same module. The last allocated frame must hold a
stack allocated variable with a same variable type and with a same element
count as a variable of IO register of callee procedure.

- CPI1 $val, #1to
Copy 1-byte emmidiate integer value 'val' to bytes of 'to' register.

- CPI2 $val, #2to
Copy 2-byte emmidiate integer value 'val' to bytes of 'to' register.

- CPI4 $val, #4to
Copy 4-byte emmidiate integer value 'val' to bytes of 'to' register.

- CPI8 $val, #to
Copy 8-byte emmidiate integer value 'val' to bytes of 'to' register.

- DEC #it
Decrements 'it' by 1.

- INC #it
Increments 'it' by 1.

- JE #op1, #op2, $off
Jumps with relative offset of 'off' instructions, if 'op1' is equal to 'op2'.
The jump must be within current stack frame.

- JG #op1, #op2, $off
Jumps with relative offset of 'off' instructions, if 'op1' is greater than
'op2'. The jump must be within current stack frame.

- JMP $off
Jumps with relative offset of 'off' instructions. The jump must be within
current stack frame.

- JNG #op1, #op2, $off
Jumps with relative offset of 'off' instructions, if 'op1' is not greater than
'op2'. The jump must be within current stack frame.

- JNZ #op, $off
Jumps with relative offset of 'off' instructions, if 'op' is not equal to zero.
The jump must be within current stack frame.

- LDB %from, $off, %to
Loads bytes with offset 'off' from first element of 'from' to first element's
bytes of 'to'. It loads as many bytes as possible.

- LDE %from, #elt, %to
Loads element 'elt' of 'from' to first element of 'to'. If element 'elt' does
not exist, an exception with code VMECODE_RANGE will be thrown. 

- LDR %from, $vref, <to
Loads variable reference with 'vref' index in first element of 'from' to stack
reference 'to'. The source and destination references must have a same
variable type. They must both have VFLAG_NON_FIXED_REF set or reset. In the
last case, they also must have a same element count. If the source reference
points to a variable, the variable is retained. If the destination reference
points to a variable, the variable is released. 

- MUL #op1, #op2, #res
Multiplies 'op1' by 'op2' and puts the result to 'res'.

- POP
Destroys a current frame. If the frame is created by PUSH instruction the
appropriate stack-allocated variable is destroyed and all variables pointed by
it's references are released. If the frame is created by PUSHR instruction,
the appropriate stack-allocated reference is destroyed. In the last case, if
the reference is assigned to a variable, then the variable is released. If the
frame is created by PUSHH instruction, then the current exception handler
becomes removed.

- PUSH @reg
Creates a new frame by allocating a new stack variable and assigning it to
register 'reg'. All bytes of the allocated variable are set to zero; all
references are set to null.

- PUSHH $off
Creates a new frame with exception handler. When an exception is caught, an
execution flow jumps with relative offset of 'off' instructions from this
point. The jump must be within current stack frame.

- PUSHR @reg
Creates a new frame by allocating a new stack reference and assigning it
to register 'reg'. The allocated reference is set to null.

      OPCODE_SUB, // SUBtract
      OPCODE_CPB, // CoPy Bytes
      OPCODE_STE, // STore array Element
      OPCODE_STB, // STore structure Bytes
      OPCODE_STR, // STore structure Reference
      
      OPCODE_THROW, // THROW exception
      OPCODE_RET // RETurn
